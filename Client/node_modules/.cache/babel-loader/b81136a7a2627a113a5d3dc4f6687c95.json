{"ast":null,"code":"var debug = require('debug')('nodemon');\nvar fs = require('fs');\nvar path = require('path');\nvar exists = fs.exists || path.exists;\nvar utils = require('../utils');\nvar rules = require('../rules');\nvar parse = require('../rules/parse');\nvar exec = require('./exec');\nvar defaults = require('./defaults');\nmodule.exports = load;\nmodule.exports.mutateExecOptions = mutateExecOptions;\nvar existsSync = fs.existsSync || path.existsSync;\nfunction findAppScript() {\n  // nodemon has been run alone, so try to read the package file\n  // or try to read the index.js file\n  if (existsSync('./index.js')) {\n    return 'index.js';\n  }\n}\n\n/**\n * Load the nodemon config, first reading the global root/nodemon.json, then\n * the local nodemon.json to the exec and then overwriting using any user\n * specified settings (i.e. from the cli)\n *\n * @param  {Object} settings user defined settings\n * @param  {Function} ready    callback that receives complete config\n */\nfunction load(settings, options, config, callback) {\n  config.loaded = [];\n  // first load the root nodemon.json\n  loadFile(options, config, utils.home, function (options) {\n    // then load the user's local configuration file\n    if (settings.configFile) {\n      options.configFile = path.resolve(settings.configFile);\n    }\n    loadFile(options, config, process.cwd(), function (options) {\n      // Then merge over with the user settings (parsed from the cli).\n      // Note that merge protects and favours existing values over new values,\n      // and thus command line arguments get priority\n      options = utils.merge(settings, options);\n\n      // legacy support\n      if (!Array.isArray(options.ignore)) {\n        options.ignore = [options.ignore];\n      }\n      if (!options.ignoreRoot) {\n        options.ignoreRoot = defaults.ignoreRoot;\n      }\n\n      // blend the user ignore and the default ignore together\n      if (options.ignoreRoot && options.ignore) {\n        if (!Array.isArray(options.ignoreRoot)) {\n          options.ignoreRoot = [options.ignoreRoot];\n        }\n        options.ignore = options.ignoreRoot.concat(options.ignore);\n      } else {\n        options.ignore = defaults.ignore.concat(options.ignore);\n      }\n\n      // add in any missing defaults\n      options = utils.merge(options, defaults);\n      if (!options.script && !options.exec) {\n        var found = findAppScript();\n        if (found) {\n          if (!options.args) {\n            options.args = [];\n          }\n          // if the script is found as a result of not being on the command\n          // line, then we move any of the pre double-dash args in execArgs\n          var n = options.scriptPosition === null ? options.args.length : options.scriptPosition;\n          options.execArgs = (options.execArgs || []).concat(options.args.splice(0, n));\n          options.scriptPosition = null;\n          options.script = found;\n        }\n      }\n      mutateExecOptions(options);\n      if (options.quiet) {\n        utils.quiet();\n      }\n      if (options.verbose) {\n        utils.debug = true;\n      }\n\n      // simplify the ready callback to be called after the rules are normalised\n      // from strings to regexp through the rules lib. Note that this gets\n      // created *after* options is overwritten twice in the lines above.\n      var ready = function ready(options) {\n        normaliseRules(options, callback);\n      };\n\n      // if we didn't pick up a nodemon.json file & there's no cli ignores\n      // then try loading an old style .nodemonignore file\n      if (config.loaded.length === 0) {\n        var legacy = loadLegacyIgnore.bind(null, options, config, ready);\n\n        // first try .nodemonignore, if that doesn't exist, try nodemon-ignore\n        return legacy('.nodemonignore', function () {\n          legacy('nodemon-ignore', function (options) {\n            ready(options);\n          });\n        });\n      }\n      ready(options);\n    });\n  });\n}\n\n/**\n * Loads the old style nodemonignore files which is a list of patterns\n * in a file to ignore\n *\n * @param  {Object} options    nodemon user options\n * @param  {Function} success\n * @param  {String} filename   ignore file (.nodemonignore or nodemon-ignore)\n * @param  {Function} fail     (optional) failure callback\n */\nfunction loadLegacyIgnore(options, config, success, filename, fail) {\n  var ignoreFile = path.join(process.cwd(), filename);\n  exists(ignoreFile, function (exists) {\n    if (exists) {\n      config.loaded.push(ignoreFile);\n      return parse(ignoreFile, function (error, rules) {\n        options.ignore = rules.raw;\n        success(options);\n      });\n    }\n    if (fail) {\n      fail(options);\n    } else {\n      success(options);\n    }\n  });\n}\nfunction normaliseRules(options, ready) {\n  // convert ignore and watch options to rules/regexp\n  rules.watch.add(options.watch);\n  rules.ignore.add(options.ignore);\n\n  // normalise the watch and ignore arrays\n  options.watch = options.watch === false ? false : rules.rules.watch;\n  options.ignore = rules.rules.ignore;\n  ready(options);\n}\n\n/**\n * Looks for a config in the current working directory, and a config in the\n * user's home directory, merging the two together, giving priority to local\n * config. This can then be overwritten later by command line arguments\n *\n * @param  {Function} ready callback to pass loaded settings to\n */\nfunction loadFile(options, config, dir, ready) {\n  if (!ready) {\n    ready = function ready() {};\n  }\n  var callback = function callback(settings) {\n    // prefer the local nodemon.json and fill in missing items using\n    // the global options\n    ready(utils.merge(settings, options));\n  };\n  if (!dir) {\n    return callback({});\n  }\n  var filename = options.configFile || path.join(dir, 'nodemon.json');\n  if (config.loaded.indexOf(filename) !== -1) {\n    // don't bother re-parsing the same config file\n    return callback({});\n  }\n  fs.readFile(filename, 'utf8', function (err, data) {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        if (!options.configFile && dir !== utils.home) {\n          // if no specified local config file and local nodemon.json\n          // doesn't exist, try the package.json\n          return loadPackageJSON(config, callback);\n        }\n      }\n      return callback({});\n    }\n    var settings = {};\n    try {\n      settings = JSON.parse(data.toString('utf8').replace(/^\\uFEFF/, ''));\n      if (!filename.endsWith('package.json') || settings.nodemonConfig) {\n        config.loaded.push(filename);\n      }\n    } catch (e) {\n      utils.log.fail('Failed to parse config ' + filename);\n      console.error(e);\n      process.exit(1);\n    }\n\n    // options values will overwrite settings\n    callback(settings);\n  });\n}\nfunction loadPackageJSON(config, ready) {\n  if (!ready) {\n    ready = function ready() {};\n  }\n  var dir = process.cwd();\n  var filename = path.join(dir, 'package.json');\n  var packageLoadOptions = {\n    configFile: filename\n  };\n  return loadFile(packageLoadOptions, config, dir, function (settings) {\n    ready(settings.nodemonConfig || {});\n  });\n}\nfunction mutateExecOptions(options) {\n  // work out the execOptions based on the final config we have\n  options.execOptions = exec({\n    script: options.script,\n    exec: options.exec,\n    args: options.args,\n    scriptPosition: options.scriptPosition,\n    nodeArgs: options.nodeArgs,\n    execArgs: options.execArgs,\n    ext: options.ext,\n    env: options.env\n  }, options.execMap);\n\n  // clean up values that we don't need at the top level\n  delete options.scriptPosition;\n  delete options.script;\n  delete options.args;\n  delete options.ext;\n  return options;\n}","map":null,"metadata":{},"sourceType":"script"}