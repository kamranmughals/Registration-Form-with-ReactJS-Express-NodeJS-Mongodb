{"ast":null,"code":"/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar _slicedToArray = require(\"D:\\\\Mern Stack\\\\Nodejs Express and MongoDB\\\\Registration-Form\\\\Client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\nvar _toConsumableArray = require(\"D:\\\\Mern Stack\\\\Nodejs Express and MongoDB\\\\Registration-Form\\\\Client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\nvar _objectSpread = require(\"D:\\\\Mern Stack\\\\Nodejs Express and MongoDB\\\\Registration-Form\\\\Client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar isNumber = require('is-number');\nvar toRegexRange = function toRegexRange(min, max, options) {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n  var opts = _objectSpread({\n    relaxZeros: true\n  }, options);\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n  var relax = String(opts.relaxZeros);\n  var shorthand = String(opts.shorthand);\n  var capture = String(opts.capture);\n  var wrap = String(opts.wrap);\n  var cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n  var a = Math.min(min, max);\n  var b = Math.max(min, max);\n  if (Math.abs(a - b) === 1) {\n    var result = min + '|' + max;\n    if (opts.capture) {\n      return \"(\".concat(result, \")\");\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return \"(?:\".concat(result, \")\");\n  }\n  var isPadded = hasPadding(min) || hasPadding(max);\n  var state = {\n    min: min,\n    max: max,\n    a: a,\n    b: b\n  };\n  var positives = [];\n  var negatives = [];\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n  if (a < 0) {\n    var newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n  if (opts.capture === true) {\n    state.result = \"(\".concat(state.result, \")\");\n  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {\n    state.result = \"(?:\".concat(state.result, \")\");\n  }\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\nfunction collatePatterns(neg, pos, options) {\n  var onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  var onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  var intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\nfunction splitToRanges(min, max) {\n  var nines = 1;\n  var zeros = 1;\n  var stop = countNines(min, nines);\n  var stops = new Set([max]);\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n  stop = countZeros(max + 1, zeros) - 1;\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n  stops = _toConsumableArray(stops);\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return {\n      pattern: start,\n      count: [],\n      digits: 0\n    };\n  }\n  var zipped = zip(start, stop);\n  var digits = zipped.length;\n  var pattern = '';\n  var count = 0;\n  for (var i = 0; i < digits; i++) {\n    var _zipped$i = _slicedToArray(zipped[i], 2),\n      startDigit = _zipped$i[0],\n      stopDigit = _zipped$i[1];\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n    } else {\n      count++;\n    }\n  }\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n  return {\n    pattern: pattern,\n    count: [count],\n    digits: digits\n  };\n}\nfunction splitToPatterns(min, max, tok, options) {\n  var ranges = splitToRanges(min, max);\n  var tokens = [];\n  var start = min;\n  var prev;\n  for (var i = 0; i < ranges.length; i++) {\n    var _max = ranges[i];\n    var obj = rangeToPattern(String(start), String(_max), options);\n    var zeros = '';\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = _max + 1;\n      continue;\n    }\n    if (tok.isPadded) {\n      zeros = padZeros(_max, tok, options);\n    }\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = _max + 1;\n    prev = obj;\n  }\n  return tokens;\n}\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  var result = [];\n  var _iterator = _createForOfIteratorHelper(arr),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var ele = _step.value;\n      var string = ele.string; // only push if _both_ are negative...\n      if (!intersection && !contains(comparison, 'string', string)) {\n        result.push(prefix + string);\n      }\n\n      // or _both_ are positive\n      if (intersection && contains(comparison, 'string', string)) {\n        result.push(prefix + string);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  var arr = [];\n  for (var i = 0; i < a.length; i++) {\n    arr.push([a[i], b[i]]);\n  }\n  return arr;\n}\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\nfunction contains(arr, key, val) {\n  return arr.some(function (ele) {\n    return ele[key] === val;\n  });\n}\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\nfunction countZeros(integer, zeros) {\n  return integer - integer % Math.pow(10, zeros);\n}\nfunction toQuantifier(digits) {\n  var _digits = _slicedToArray(digits, 2),\n    _digits$ = _digits[0],\n    start = _digits$ === void 0 ? 0 : _digits$,\n    _digits$2 = _digits[1],\n    stop = _digits$2 === void 0 ? '' : _digits$2;\n  if (stop || start > 1) {\n    return \"{\".concat(start + (stop ? ',' + stop : ''), \"}\");\n  }\n  return '';\n}\nfunction toCharacterClass(a, b, options) {\n  return \"[\".concat(a).concat(b - a === 1 ? '' : '-').concat(b, \"]\");\n}\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n  var diff = Math.abs(tok.maxLen - String(value).length);\n  var relax = options.relaxZeros !== false;\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default:\n      {\n        return relax ? \"0{0,\".concat(diff, \"}\") : \"0{\".concat(diff, \"}\");\n      }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = function () {\n  return toRegexRange.cache = {};\n};\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;","map":null,"metadata":{},"sourceType":"script"}