{"ast":null,"code":"var colour = require('./colour');\nvar bus = require('./bus');\nvar required = false;\nvar useColours = true;\nvar coding = {\n  log: 'black',\n  info: 'yellow',\n  status: 'green',\n  detail: 'yellow',\n  fail: 'red',\n  error: 'red'\n};\nfunction log(type, text) {\n  var msg = '[nodemon] ' + (text || '');\n  if (useColours) {\n    msg = colour(coding[type], msg);\n  }\n\n  // always push the message through our bus, using nextTick\n  // to help testing and get _out of_ promises.\n  process.nextTick(function () {\n    bus.emit('log', {\n      type: type,\n      message: text,\n      colour: msg\n    });\n  });\n\n  // but if we're running on the command line, also echo out\n  // question: should we actually just consume our own events?\n  if (!required) {\n    if (type === 'error') {\n      console.error(msg);\n    } else {\n      console.log(msg || '');\n    }\n  }\n}\nvar Logger = function Logger(r) {\n  if (!(this instanceof Logger)) {\n    return new Logger(r);\n  }\n  this.required(r);\n  return this;\n};\nObject.keys(coding).forEach(function (type) {\n  Logger.prototype[type] = log.bind(null, type);\n});\n\n// detail is for messages that are turned on during debug\nLogger.prototype.detail = function (msg) {\n  if (this.debug) {\n    log('detail', msg);\n  }\n};\nLogger.prototype.required = function (val) {\n  required = val;\n};\nLogger.prototype.debug = false;\nLogger.prototype._log = function (type, msg) {\n  if (required) {\n    bus.emit('log', {\n      type: type,\n      message: msg || '',\n      colour: msg || ''\n    });\n  } else if (type === 'error') {\n    console.error(msg);\n  } else {\n    console.log(msg || '');\n  }\n};\nObject.defineProperty(Logger.prototype, 'useColours', {\n  set: function set(val) {\n    useColours = val;\n  },\n  get: function get() {\n    return useColours;\n  }\n});\nmodule.exports = Logger;","map":null,"metadata":{},"sourceType":"script"}