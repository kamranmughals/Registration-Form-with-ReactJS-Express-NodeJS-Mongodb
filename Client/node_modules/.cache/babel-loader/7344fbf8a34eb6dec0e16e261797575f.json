{"ast":null,"code":"module.exports.watch = watch;\nmodule.exports.resetWatchers = resetWatchers;\nvar debug = require('debug')('nodemon:watch');\nvar debugRoot = require('debug')('nodemon');\nvar chokidar = require('chokidar');\nvar undefsafe = require('undefsafe');\nvar config = require('../config');\nvar path = require('path');\nvar utils = require('../utils');\nvar bus = utils.bus;\nvar match = require('./match');\nvar watchers = [];\nvar debouncedBus;\nbus.on('reset', resetWatchers);\nfunction resetWatchers() {\n  debugRoot('resetting watchers');\n  watchers.forEach(function (watcher) {\n    watcher.close();\n  });\n  watchers = [];\n}\nfunction watch() {\n  if (watchers.length) {\n    debug('early exit on watch, still watching (%s)', watchers.length);\n    return;\n  }\n  var dirs = [].slice.call(config.dirs);\n  debugRoot('start watch on: %s', dirs.join(', '));\n  var rootIgnored = config.options.ignore;\n  debugRoot('ignored', rootIgnored);\n  var watchedFiles = [];\n  var promise = new Promise(function (resolve) {\n    var dotFilePattern = /[/\\\\]\\./;\n    var ignored = match.rulesToMonitor([],\n    // not needed\n    Array.from(rootIgnored), config).map(function (pattern) {\n      return pattern.slice(1);\n    });\n    var addDotFile = dirs.filter(function (dir) {\n      return dir.match(dotFilePattern);\n    });\n\n    // don't ignore dotfiles if explicitly watched.\n    if (addDotFile.length === 0) {\n      ignored.push(dotFilePattern);\n    }\n    var watchOptions = {\n      ignorePermissionErrors: true,\n      ignored: ignored,\n      persistent: true,\n      usePolling: config.options.legacyWatch || false,\n      interval: config.options.pollingInterval\n      // note to future developer: I've gone back and forth on adding `cwd`\n      // to the props and in some cases it fixes bugs but typically it causes\n      // bugs elsewhere (since nodemon is used is so many ways). the final\n      // decision is to *not* use it at all and work around it\n      // cwd: ...\n    };\n\n    if (utils.isWindows) {\n      watchOptions.disableGlobbing = true;\n    }\n    if (process.env.TEST) {\n      watchOptions.useFsEvents = false;\n    }\n    var watcher = chokidar.watch(dirs, Object.assign({}, watchOptions, config.options.watchOptions || {}));\n    watcher.ready = false;\n    var total = 0;\n    watcher.on('change', filterAndRestart);\n    watcher.on('add', function (file) {\n      if (watcher.ready) {\n        return filterAndRestart(file);\n      }\n      watchedFiles.push(file);\n      bus.emit('watching', file);\n      debug('chokidar watching: %s', file);\n    });\n    watcher.on('ready', function () {\n      watchedFiles = Array.from(new Set(watchedFiles)); // ensure no dupes\n      total = watchedFiles.length;\n      watcher.ready = true;\n      resolve(total);\n      debugRoot('watch is complete');\n    });\n    watcher.on('error', function (error) {\n      if (error.code === 'EINVAL') {\n        utils.log.error('Internal watch failed. Likely cause: too many ' + 'files being watched (perhaps from the root of a drive?\\n' + 'See https://github.com/paulmillr/chokidar/issues/229 for details');\n      } else {\n        utils.log.error('Internal watch failed: ' + error.message);\n        process.exit(1);\n      }\n    });\n    watchers.push(watcher);\n  });\n  return promise.catch(function (e) {\n    // this is a core error and it should break nodemon - so I have to break\n    // out of a promise using the setTimeout\n    setTimeout(function () {\n      throw e;\n    });\n  }).then(function () {\n    utils.log.detail(\"watching \".concat(watchedFiles.length, \" file\").concat(watchedFiles.length === 1 ? '' : 's'));\n    return watchedFiles;\n  });\n}\nfunction filterAndRestart(files) {\n  if (!Array.isArray(files)) {\n    files = [files];\n  }\n  if (files.length) {\n    var cwd = process.cwd();\n    if (this.options && this.options.cwd) {\n      cwd = this.options.cwd;\n    }\n    utils.log.detail('files triggering change check: ' + files.map(function (file) {\n      var res = path.relative(cwd, file);\n      return res;\n    }).join(', '));\n\n    // make sure the path is right and drop an empty\n    // filenames (sometimes on windows)\n    files = files.filter(Boolean).map(function (file) {\n      return path.relative(process.cwd(), path.relative(cwd, file));\n    });\n    if (utils.isWindows) {\n      // ensure the drive letter is in uppercase (c:\\foo -> C:\\foo)\n      files = files.map(function (f) {\n        if (f.indexOf(':') === -1) {\n          return f;\n        }\n        return f[0].toUpperCase() + f.slice(1);\n      });\n    }\n    debug('filterAndRestart on', files);\n    var matched = match(files, config.options.monitor, undefsafe(config, 'options.execOptions.ext'));\n    debug('matched?', JSON.stringify(matched));\n\n    // if there's no matches, then test to see if the changed file is the\n    // running script, if so, let's allow a restart\n    if (config.options.execOptions && config.options.execOptions.script) {\n      var script = path.resolve(config.options.execOptions.script);\n      if (matched.result.length === 0 && script) {\n        var length = script.length;\n        files.find(function (file) {\n          if (file.substr(-length, length) === script) {\n            matched = {\n              result: [file],\n              total: 1\n            };\n            return true;\n          }\n        });\n      }\n    }\n    utils.log.detail('changes after filters (before/after): ' + [files.length, matched.result.length].join('/'));\n\n    // reset the last check so we're only looking at recently modified files\n    config.lastStarted = Date.now();\n    if (matched.result.length) {\n      if (config.options.delay > 0) {\n        utils.log.detail('delaying restart for ' + config.options.delay + 'ms');\n        if (debouncedBus === undefined) {\n          debouncedBus = debounce(restartBus, config.options.delay);\n        }\n        debouncedBus(matched);\n      } else {\n        return restartBus(matched);\n      }\n    }\n  }\n}\nfunction restartBus(matched) {\n  utils.log.status('restarting due to changes...');\n  matched.result.map(function (file) {\n    utils.log.detail(path.relative(process.cwd(), file));\n  });\n  if (config.options.verbose) {\n    utils.log._log('');\n  }\n  bus.emit('restart', matched.result);\n}\nfunction debounce(fn, delay) {\n  var timer = null;\n  return function () {\n    var context = this;\n    var args = arguments;\n    clearTimeout(timer);\n    timer = setTimeout(function () {\n      return fn.apply(context, args);\n    }, delay);\n  };\n}","map":null,"metadata":{},"sourceType":"script"}